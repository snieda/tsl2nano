<project name="ant.shell" default="help">
	<description id="description">
==============================================================================
Basic Ant-Script to provide most file, java, sql, xml functionalities.
May be used as base-build-script for java-projects
Author: Thomas Schneider 2012
==============================================================================
Help on defining properties:
 On ant the first definition of a property will win - it is not possible to
 overwrite a defined property! If you need to redefine properties, you should
 call ant tasks through tag 'ant' or 'antcall' setting quasi local properties
 inside that tag (on antcall through 'param', on ant through 'property').

some internals:
 - set your properties like that: mypath=${java.dir}/addpath
   or e.g. in windows: mypath=%CD%/addpath
 - all system environment and java vars will be accessed through
   namespace 'sh'. e.g. srcdir will be sh.srcdir
 - it is possible to set properties in shell.properties
 - it is possible to disable targets with 'sh.disable' + target-name
   this enables condition-like working.
 - standard classpath will be the current dir including all files
 - if vars are not defined, default values will be used:
	libraries   : ./lib
	java-src    : ./src
	java-classes: ./bin
	include     : **
	exclude     : EXCLUDING_EXPRESSION
	main-class  : org.junit.runner.JUnitCore
==============================================================================
	</description>

	<!-- Project standard build definitions -->
	<property file="shell.properties" />

	<!-- Environment -->
	<property environment="sh" />
	<tstamp>
		<format property="tstamp" pattern="yyyyMMdd-HHmm" />
	</tstamp>

	<target name="help" description="help overview" unless="sh.disable.help">
		<!-- <echoproperties/> -->
		<echo message="@{description}">
		</echo>
		<antcall target="man" />
		<!--
		TODO:
		ssh
		filter, find
		schemavalidate
		signjar, getkey
		sshexec
		buildnumber
		wikitext-to-html
		jaxb.schemagen
		-->
	</target>
	<target name="man" unless="sh.disable.man">
		<antcall target="sh.xml.xpath">
			<param name="sh.xml.xpath.file" value="${basedir}/shell.xml" />
			<param name="sh.xml.xpath.expression" value="//target/@concat(//target/@name,': ',//target/@description)" />
		</antcall>
	</target>

	<path id="sh.stdpath.id">
		<fileset dir="${basedir}">
			<include name="**" />
		</fileset>
	</path>

	<path id="sh.classpath.id">
		<fileset dir="${basedir}">
			<include name="**/*.jar" />
		</fileset>
		<dirset dir="./">
			<include name="${sh.java.bindir}" />
		</dirset>
		<dirset dir="./" />
	</path>

	<!-- add properties on runtime through user input -->
	<target name="sh.input" unless="${sh.input.name}">
		<property name="sh.input.default" value="" />
		<input message="${sh.input.name}: " addProperty="${sh.input.name}" defaultvalue="${sh.input.default}" />
	</target>
	<!--	<target name="sh.input" unless="${sh.input.name}">
		<property name="sh.input.default" value="" />
		<sh.input sh.input.name="${sh.input.name}" sh.input.default="${sh.input.default}" />
	</target>
	<macrodef name="sh.input" description="asks for user input to set property if not set yet.">
		<attribute name="sh.input.name" />
		<attribute name="sh.input.default"/>
		<sequential>
			<input message="@{sh.input.name}: " addProperty="@{sh.input.name}" defaultvalue="@{sh.input.default}" />
			<echo message="@{sh.input.name} = ${@{sh.input.name}}" />
		</sequential>
	</macrodef>
-->
	<target name="sh.jar" unless="sh.disable.jar" description="packs files into a zip-encoded file">
		<!-- fallbacks -->
		<property name="sh.jar.srcdir" value="./" />
		<property name="sh.jar.include" value="**" />
		<property name="sh.jar.include2" value="INCLUDING_EXPRESSION" />
		<property name="sh.jar.include3" value="INCLUDING_EXPRESSION" />
		<property name="sh.jar.include4" value="INCLUDING_EXPRESSION" />
		<property name="sh.jar.exclude" value="EXCLUDING_EXPRESSION" />
		<property name="sh.jar.exclude2" value="EXCLUDING_EXPRESSION2" />
		<property name="sh.jar.exclude3" value="EXCLUDING_EXPRESSION3" />
		<property name="sh.jar.exclude4" value="EXCLUDING_EXPRESSION3" />
		<property name="sh.jar.destination" value="${basedir}.jar" />
		<property name="sh.jar.manifest" value="${sh.java.manifest.file}" />

		<!-- start it -->
		<sh.jar sh.jar.srcdir="${sh.jar.srcdir}" sh.jar.include="${sh.jar.include}" sh.jar.include2="${sh.jar.include2}" sh.jar.include3="${sh.jar.include3}" sh.jar.include4="${sh.jar.include4}" sh.jar.exclude="${sh.jar.exclude}" sh.jar.exclude2="${sh.jar.exclude2}" sh.jar.exclude3="${sh.jar.exclude3}" sh.jar.exclude4="${sh.jar.exclude4}" sh.jar.destination="${sh.jar.destination}" sh.jar.manifest="${sh.jar.manifest}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.jar" description="packs files into a zip-encoded file">
		<attribute name="sh.jar.srcdir" />
		<attribute name="sh.jar.include" />
		<attribute name="sh.jar.include2" />
		<attribute name="sh.jar.include3" />
		<attribute name="sh.jar.include4" />
		<attribute name="sh.jar.exclude" />
		<attribute name="sh.jar.exclude2" />
		<attribute name="sh.jar.exclude3" />
		<attribute name="sh.jar.exclude4" />
		<attribute name="sh.jar.destination" />
		<attribute name="sh.jar.manifest" />

		<sequential>
			<jar destfile="@{sh.jar.destination}" manifest="@{sh.jar.manifest}" update="true">
				<fileset dir="@{sh.jar.srcdir}">
					<include name="@{sh.jar.include}" />
					<include name="@{sh.jar.include2}" />
					<include name="@{sh.jar.include3}" />
					<include name="@{sh.jar.include4}" />
					<exclude name="@{sh.jar.exclude}" />
					<exclude name="@{sh.jar.exclude2}" />
					<exclude name="@{sh.jar.exclude3}" />
					<exclude name="@{sh.jar.exclude4}" />
				</fileset>
			</jar>
		</sequential>
	</macrodef>

	<!-- useable to be started by shell-scripts. all environment variables are stored into 'sh'.
	     you may define the following vars:
	     - (*) unjar.destination: output directory
	     - (*) unjar.srcdir     : base dir to search for packed files 
	     -     unjar.include    : expr. for packed files to include (if not defined, all is inlcluded)
	     -     unjar.exclude    : expr. for packed files to exclude (if not defined, nothing is excluded)
	-->
	<target name="sh.unjar" unless="sh.disable.unjar" description="unpacks a zip-encoded file">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.unjar.srcdir" value="${basedir}" />
		<property name="sh.unjar.destination" value="${sh.unjar.srcdir}" />
		<property name="sh.unjar.include" value="*.*ar" />
		<property name="sh.unjar.exclude" value="EXCLUDING_EXPRESSION" />
		<!-- start it -->
		<sh.unjar sh.unjar.srcdir="${sh.unjar.srcdir}" sh.unjar.include="${sh.unjar.include}" sh.unjar.exclude="${sh.unjar.exclude}" sh.unjar.destination="${sh.unjar.destination}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.unjar" description="unpacks a zip-encoded file">
		<attribute name="sh.unjar.srcdir" />
		<attribute name="sh.unjar.include" />
		<attribute name="sh.unjar.exclude" />
		<attribute name="sh.unjar.destination" />
		<sequential>
			<unjar dest="@{sh.unjar.destination}">
				<fileset dir="@{sh.unjar.srcdir}">
					<include name="@{sh.unjar.include}" />
					<exclude name="@{sh.unjar.exclude}" />
				</fileset>
			</unjar>
		</sequential>
	</macrodef>

	<description>
target: sh.copy
	useable to be started by shell-scripts. all environment variables are stored into 'sh'.
	     you may define the following vars:
	     - (*) copy.destination: output directory
	     - (*) copy.srcdir     : base dir to search for files 
	     -     copy.include    : expr. for files to include (if not defined, all is inlcluded)
	     -     copy.exclude    : expr. for files to exclude (if not defined, nothing is excluded)
	</description>
	<target name="sh.copy" unless="sh.disable.copy" description="copies a given fileset to a directory">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.copy.srcdir" value="${basedir}" />
		<property name="sh.copy.destination" value="${user.home}/sh.copy" />
		<property name="sh.copy.include" value="**" />
		<property name="sh.copy.exclude" value="EXCLUDING_EXPRESSION" />
		<property name="sh.copy.flatten" value="false" />
		<property name="sh.copy.includeemptydirs" value="false" />
		<!-- start it -->
		<sh.copy sh.copy.srcdir="${sh.copy.srcdir}" sh.copy.include="${sh.copy.include}" sh.copy.exclude="${sh.copy.exclude}" sh.copy.destination="${sh.copy.destination}" sh.copy.flatten="${sh.copy.flatten}" sh.copy.includeemptydirs="${sh.copy.includeemptydirs}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.copy" description="copies a given fileset to a directory">
		<attribute name="sh.copy.srcdir" />
		<attribute name="sh.copy.include" />
		<attribute name="sh.copy.exclude" />
		<attribute name="sh.copy.destination" />
		<attribute name="sh.copy.flatten" />
		<attribute name="sh.copy.includeemptydirs" />
		<sequential>
			<mkdir dir="${sh.copy.destination}" />
			<copy todir="${sh.copy.destination}" flatten="${sh.copy.flatten}" includeemptydirs="${sh.copy.includeemptydirs}" preservelastmodified="true">
				<fileset dir="${sh.copy.srcdir}">
					<include name="${sh.copy.include}" />
					<exclude name="${sh.copy.exclude}" />
				</fileset>
			</copy>
		</sequential>
	</macrodef>

	<description>
target: sh.delete
	useable to be started by shell-scripts. all environment variables are stored into 'sh'.
	     you may define the following vars:
	     - (*) delete.srcdir     : base dir to search for files 
	     -     delete.include    : expr. for files to include (if not defined, all is inlcluded)
	     -     delete.exclude    : expr. for files to exclude (if not defined, nothing is excluded)
	</description>
	<target name="sh.delete" unless="sh.disable.delete" description="deletes a given fileset">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.delete.srcdir" value="${basedir}" />
		<property name="sh.delete.include" value="**" />
		<property name="sh.delete.exclude" value="EXCLUDING_EXPRESSION" />
		<!-- start it -->
		<sh.delete sh.delete.srcdir="${sh.delete.srcdir}" sh.delete.include="${sh.delete.include}" sh.delete.exclude="${sh.delete.exclude}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.delete" description="deletes a given fileset">
		<attribute name="sh.delete.srcdir" />
		<attribute name="sh.delete.include" />
		<attribute name="sh.delete.exclude" />
		<sequential>
			<delete includeemptydirs="true" quiet="false" failonerror="false">
				<fileset dir="${sh.delete.srcdir}">
					<include name="${sh.delete.include}" />
					<exclude name="${sh.delete.exclude}" />
				</fileset>
			</delete>
		</sequential>
	</macrodef>

	<!-- does a check, if src and dest are equal - then move will not be called! -->
	<target name="sh.move" unless="sh.disable.move" description="copies and deletes directory">
		<property name="sh.stepover.description" value="steping over task move because sh.move.srcdir and sh.move.destination are equal!" />
		<condition property="sh.antcall.target.name" value="sh.stepover" else="sh.move.internal">
			<equals arg1="${sh.move.srcdir}" arg2="${sh.move.destination}" />
		</condition>
		<antcall target="${sh.antcall.target.name}" />
	</target>
	<target name="sh.move.internal" unless="sh.disable.move" description="copies and deletes directory">
		<property name="sh.copy.srcdir" value="${sh.move.srcdir}" />
		<property name="sh.copy.destination" value="${sh.move.destination}" />
		<antcall target="sh.copy" />

		<property name="sh.delete.srcdir" value="${sh.move.srcdir}" />
		<antcall target="sh.delete" />
	</target>

	<!-- concats a set of files into one file -->
	<target name="sh.concat">
		<concat destfile="${sh.concat.destfile}">
			<fileset dir="${sh.concat.dir}">
				<include name="${sh.concat.include}" />
				<exclude name="${sh.concat.exclude}" />
			</fileset>
		</concat>
	</target>

	<!-- Workaround for checks, if a task should be started -->
	<target name="sh.stepover" description="${sh.stepover.description}">
		<echo message="${sh.stepover.description}" />
	</target>

	<target name="sh.find.files" unless="sh.disable.find.files" description="not implemented yet">
		<fail message="not implemented. Overwrite in your build file" />
	</target>

	<target name="sh.regexp.replace" unless="sh.disable.regexp.replace" description="does a search/replace on given regexp and fileset">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.regexp.srcdir" value="${basedir}" />
		<property name="sh.regexp.include" value="**" />
		<property name="sh.regexp.exclude" value="EXCLUDING_EXPRESSION" />
		<!-- start it -->
		<sh.regexp.replace sh.regexp.srcdir="${sh.regexp.srcdir}" sh.regexp.include="${sh.regexp.include}" sh.regexp.exclude="${sh.regexp.exclude}" sh.regexp.pattern="${sh.regexp.pattern}" sh.regexp.subst="${sh.regexp.subst}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.regexp.replace" description="does a search/replace on given regexp and fileset">
		<attribute name="sh.regexp.srcdir" />
		<attribute name="sh.regexp.include" />
		<attribute name="sh.regexp.exclude" />
		<attribute name="sh.regexp.pattern" />
		<attribute name="sh.regexp.subst" />
		<sequential>
			<echo message="regexp (file:@{sh.regexp.srcdir}): @{sh.regexp.pattern} ==> @{sh.regexp.subst}" />
			<replaceregexp flags="g" byline="true">
				<regexp pattern="@{sh.regexp.pattern}" />
				<substitution expression="@{sh.regexp.subst}" />
				<fileset dir="@{sh.regexp.srcdir}">
					<include name="@{sh.regexp.include}" />
					<exclude name="@{sh.regexp.exclude}" />
				</fileset>
			</replaceregexp>
		</sequential>
	</macrodef>

	<target name="sh.ftp" unless="sh.disable.ftp" description="starts an ftp session to get/put files to given host">
		<ftp action="${sh.ftp.action}" binary="${sh.ftp.binary}" port="${sh.ftp.port}" password="${sh.ftp.passwd}" server="${sh.ftp.server}" userid="${sh.ftp.user}">
			<fileset dir="${sh.ftp.dir}">
				<include name="${sh.ftp.include}" />
			</fileset>
		</ftp>
	</target>

	<target name="sh.script" unless="sh.disable.script" description="starts language scripts">
		<script classpathref="sh.classpath.id" language="${sh.script.language}" src="${sh.script.dir}/${sh.script.includes}" />
	</target>

	<target name="sh.sql" unless="sh.disable.sql" description="starts sql scripts">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.sql.driver" value="${jdbc.driver}" />
		<property name="sh.sql.url" value="${jdbc.url}" />
		<property name="sh.sql.userid" value="${jdbc.username}" />
		<property name="sh.sql.password" value="${jdbc.password}" />
		<property name="sh.sql.dir" value="${basedir}" />
		<property name="sh.sql.include" value="*.sql" />
		<property name="sh.sql.include2" value="INCLUDING_EXPRESSION" />
		<property name="sh.sql.include3" value="INCLUDING_EXPRESSION" />
		<property name="sh.sql.include4" value="INCLUDING_EXPRESSION" />
		<property name="sh.sql.exclude" value="EXCLUDING_EXPRESSION" />
		<property name="sh.sql.exclude2" value="EXCLUDING_EXPRESSION" />
		<property name="sh.sql.exclude3" value="EXCLUDING_EXPRESSION" />
		<property name="sh.sql.exclude4" value="EXCLUDING_EXPRESSION" />
		<property name="sh.sql.onerror" value="abort" />
		<property name="sh.sql.encoding" value="Cp1252" />
		<!-- start it -->
		<sh.sql sh.sql.driver="${sh.sql.driver}" sh.sql.url="${sh.sql.url}" sh.sql.userid="${sh.sql.userid}" sh.sql.password="${sh.sql.password}" sh.sql.include="${sh.sql.include}" sh.sql.include2="${sh.sql.include2}" sh.sql.include3="${sh.sql.include3}" sh.sql.include4="${sh.sql.include4}" sh.sql.exclude="${sh.sql.exclude}" sh.sql.exclude2="${sh.sql.exclude2}" sh.sql.exclude3="${sh.sql.exclude3}" sh.sql.exclude4="${sh.sql.exclude4}" sh.sql.onerror="${sh.sql.onerror}" sh.sql.encoding="${sh.sql.encoding}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.sql" description="runs sql scripts on given fileset">
		<attribute name="sh.sql.driver" />
		<attribute name="sh.sql.url" />
		<attribute name="sh.sql.userid" />
		<attribute name="sh.sql.password" />
		<attribute name="sh.sql.include" />
		<attribute name="sh.sql.include2" />
		<attribute name="sh.sql.include3" />
		<attribute name="sh.sql.include4" />
		<attribute name="sh.sql.exclude" />
		<attribute name="sh.sql.exclude2" />
		<attribute name="sh.sql.exclude3" />
		<attribute name="sh.sql.exclude4" />
		<attribute name="sh.sql.onerror" />
		<attribute name="sh.sql.encoding" />
		<sequential>
			<sql classpathref="sh.stdpath.id" encoding="@{sh.sql.encoding}" driver="@{sh.sql.driver}" url="@{sh.sql.url}" userid="@{sh.sql.userid}" password="@{sh.sql.password}" onerror="@{sh.sql.onerror}" autocommit="true" print="true">
				<fileset dir="${sh.sql.dir}">
					<include name="@{sh.sql.include}" />
					<include name="@{sh.sql.include2}" />
					<include name="@{sh.sql.include3}" />
					<include name="@{sh.sql.include4}" />
					<exclude name="@{sh.sql.exclude}" />
					<exclude name="@{sh.sql.exclude2}" />
					<exclude name="@{sh.sql.exclude3}" />
					<exclude name="@{sh.sql.exclude4}" />
				</fileset>
			</sql>
		</sequential>
	</macrodef>

	<target name="sh.printinfo" description="prints some system informations to the standard output">
		<echo>
===========================================================
starting ${ant.project.name}:
	script: ${ant.file}
	target: ${ant.project.invoked-targets}
	encode: ${file.encoding}
	dir   : ${user.dir}
	base  : ${basedir}
	time  : ${DSTAMP} ${TSTAMP}
	user  : ${user.name}, home: ${user.home}
	lang  : ${user.country}_${user.language}, encoding: ${sun.jnu.encoding}
	java  : ${java.runtime.version}, ${java.home}
	ant   : ${ant.home}
	os    : ${os.name}, ${os.version} ${sun.os.patch.level} ${os.arch}
	system: ${sun.cpu.isalist} ${sun.arch.data.model}
===========================================================
		</echo>
		<echoproperties format="text" />

	</target>

	<target name="sh.sleep" unless="sh.disable.sleep" description="sleeps for given milliseconds">
		<echo message="sleeping for ${sh.sleep.milliseconds} milliseconds..." />
		<sleep milliseconds="${sh.sleep.milliseconds}" />
	</target>

	<target name="sh.init" unless="sh.disable.init" description="creates all java project directories">
		<mkdir dir="${sh.java.lib.dir}" />
		<mkdir dir="${sh.java.bin.dir}" />
		<mkdir dir="${sh.java.target.dir}" />
	</target>

	<target name="sh.clean" unless="sh.disable.clean" depends="sh.init" description="cleans all binaries">
		<!-- fallbacks -->
		<property name="sh.clean.basedir" value="${basedir}" />
		<property name="sh.clean.bin.dir" value="${basedir}/${sh.java.bin.dir}" />
		<property name="sh.clean.target.dir" value="${basedir}/${sh.java.target.dir}" />
		<!-- <echo message="cleaning ${sh.clean.bin.dir} and ${sh.clean.target.dir}" /> -->
		<sh.clean sh.clean.basedir="${sh.clean.basedir}" sh.clean.bin.dir="${sh.clean.bin.dir}" sh.clean.target.dir="${sh.clean.target.dir}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.clean" description="cleans all binaries">
		<attribute name="sh.clean.basedir" />
		<attribute name="sh.clean.bin.dir" />
		<attribute name="sh.clean.target.dir" />
		<sequential>
			<delete dir="@{sh.clean.bin.dir}" />
			<delete dir="@{sh.clean.target.dir}" />
		</sequential>
	</macrodef>

	<target name="sh.compile" unless="sh.disable.compile" description="compiles java sources to class files">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.compile.include" value="**" />
		<property name="sh.compile.exclude" value="EXCLUDING_EXPRESSION" />
		<property name="sh.compile.srcdir" value="${basedir}/src" />
		<property name="sh.compile.srcdir2" value="${sh.compile.srcdir}" />
		<property name="sh.compile.srcdir3" value="${sh.compile.srcdir}" />
		<property name="sh.compile.srcdir4" value="${sh.compile.srcdir}" />
		<property name="sh.compile.bindir" value="${basedir}/bin" />
		<property name="sh.compile.classpath" value="${basedir}/lib" />
		<property name="sh.compile.classpath2" value="${sh.compile.classpath}" />
		<property name="sh.compile.classpath3" value="${sh.compile.classpath}" />
		<property name="sh.compile.classpath4" value="${sh.compile.classpath}" />
		<property name="sh.compile.debug" value="false" />
		<property name="sh.compile.cargs" value="-nowarn" />
		<property name="sh.java.encoding" value="cp1252" />
		<property name="sh.compile.encoding" value="${sh.java.encoding}" />

		<!-- start it -->
		<sh.compile sh.compile.srcdir="${sh.compile.srcdir}" sh.compile.srcdir2="${sh.compile.srcdir2}" sh.compile.srcdir3="${sh.compile.srcdir3}" sh.compile.srcdir4="${sh.compile.srcdir4}" sh.compile.include="${sh.compile.include}" sh.compile.exclude="${sh.compile.exclude}" sh.compile.bindir="${sh.compile.bindir}" sh.compile.classpath="${sh.compile.classpath}" sh.compile.classpath2="${sh.compile.classpath2}" sh.compile.classpath3="${sh.compile.classpath3}" sh.compile.classpath4="${sh.compile.classpath4}" sh.compile.debug="${sh.compile.debug}" sh.compile.extdirs="${sh.compile.extdirs}" sh.compile.cargs="${sh.compile.cargs}" sh.compile.encoding="${sh.compile.encoding}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.compile" description="compiles java sources to class files">
		<attribute name="sh.compile.include" />
		<attribute name="sh.compile.exclude" />
		<attribute name="sh.compile.srcdir" />
		<attribute name="sh.compile.srcdir2" />
		<attribute name="sh.compile.srcdir3" />
		<attribute name="sh.compile.srcdir4" />
		<attribute name="sh.compile.bindir" />
		<attribute name="sh.compile.classpath" />
		<attribute name="sh.compile.classpath2" />
		<attribute name="sh.compile.classpath3" />
		<attribute name="sh.compile.classpath4" />
		<attribute name="sh.compile.extdirs" />
		<attribute name="sh.compile.cargs" />
		<attribute name="sh.compile.debug" />
		<attribute name="sh.compile.encoding" />
		<sequential>
			<mkdir dir="@{sh.compile.bindir}" />

			<!-- 'optimize is true, if debug is false and vice versa -->
			<condition property="optimize" value="false">
				<isset property="sh.compile.debug" />
			</condition>
			<property name="optimize" value="true" />

			<echo>
compiler basedir: ${basedir}. classpath: @{sh.compile.classpath};@{sh.compile.classpath2};@{sh.compile.classpath3};@{sh.compile.classpath4}
	src: @{sh.compile.srcdir}, @{sh.compile.srcdir2}, @{sh.compile.srcdir3}, @{sh.compile.srcdir4}
			</echo>
			<javac destdir="@{sh.compile.bindir}" listfiles="@{sh.compile.debug}" depend="true" debuglevel="lines,vars,source" verbose="@{sh.compile.debug}" nowarn="true" optimize="${optimize}" debug="@{sh.compile.debug}" extdirs="@{sh.compile.extdirs}" encoding="@{sh.compile.encoding}">
				<classpath>
					<fileset dir="@{sh.compile.classpath}">
						<include name="**/*.jar" />
						<include name="**/*.class" />
					</fileset>
					<fileset dir="@{sh.compile.classpath2}">
						<include name="**/*.jar" />
						<include name="**/*.class" />
					</fileset>
					<fileset dir="@{sh.compile.classpath3}">
						<include name="**/*.jar" />
						<include name="**/*.class" />
					</fileset>
					<fileset dir="@{sh.compile.classpath4}">
						<include name="**/*.jar" />
						<include name="**/*.class" />
					</fileset>
				</classpath>
				<src path="@{sh.compile.srcdir}" />
				<src path="@{sh.compile.srcdir2}" />
				<src path="@{sh.compile.srcdir3}" />
				<src path="@{sh.compile.srcdir4}" />
				<include name="@{sh.compile.include}" />
				<exclude name="@{sh.compile.exclude}" />
				<compilerarg value="@{sh.compile.cargs}" />
			</javac>

			<!-- copy resource files to bin -->
			<copy todir="@{sh.compile.bindir}" preservelastmodified="on">
				<fileset dir="@{sh.compile.srcdir}">
					<exclude name="**/*.java" />
				</fileset>
				<fileset dir="@{sh.compile.srcdir2}">
					<exclude name="**/*.java" />
				</fileset>
				<fileset dir="@{sh.compile.srcdir3}">
					<exclude name="**/*.java" />
				</fileset>
				<fileset dir="@{sh.compile.srcdir4}">
					<exclude name="**/*.java" />
				</fileset>
			</copy>

		</sequential>
	</macrodef>

	<target name="sh.java" unless="sh.disable.java" description="starts a given java main method (default: junit)">
		<!-- if not defined, use some defaults ... -->
		<property name="sh.java.bindir" value="bin" />
		<property name="sh.java.classpath" value="lib" />
		<property name="sh.java.classname" value="org.junit.runner.JUnitCore" />
		<property name="sh.java.encoding" value="cp1252" />
		<property name="sh.java.manifest.file" value="META-INF/MANIFEST.MF" />

		<!-- the caller may set the sh.java.argX or simple argX value -->
		<condition property="sh.java.arg1" value="${arg1}" else="">
			<isset property="arg1" />
		</condition>
		<condition property="sh.java.arg2" value="${arg2}" else="">
			<isset property="arg2" />
		</condition>
		<condition property="sh.java.arg3" value="${arg3}" else="">
			<isset property="arg3" />
		</condition>
		<condition property="sh.java.arg4" value="${arg4}" else="">
			<isset property="arg4" />
		</condition>
		<condition property="sh.java.arg5" value="${arg5}" else="">
			<isset property="arg5" />
		</condition>
		<condition property="sh.java.arg6" value="${arg6}" else="">
			<isset property="arg6" />
		</condition>

		<!-- start it -->
		<sh.java sh.java.bindir="${sh.java.bindir}" sh.java.classpath="${sh.java.classpath}" sh.java.classname="${sh.java.classname}" sh.java.arg1="${sh.java.arg1}" sh.java.arg2="${sh.java.arg2}" sh.java.arg3="${sh.java.arg3}" sh.java.arg4="${sh.java.arg4}" sh.java.arg5="${sh.java.arg5}" sh.java.arg6="${sh.java.arg6}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.java" description="starts a given java main method (default: junit)">
		<attribute name="sh.java.bindir" />
		<attribute name="sh.java.classpath" />
		<attribute name="sh.java.classname" />

		<attribute name="sh.java.arg1" />
		<attribute name="sh.java.arg2" />
		<attribute name="sh.java.arg3" />
		<attribute name="sh.java.arg4" />
		<attribute name="sh.java.arg5" />
		<attribute name="sh.java.arg6" />
		<sequential>
			<!-- <echoproperties/> -->
			<echo message="Starting @{sh.java.classname}.main(args)" />
			<echo>
	arg1: @{sh.java.arg1}
	arg2: @{sh.java.arg2}
	arg3: @{sh.java.arg3}
	arg4: @{sh.java.arg4}
	arg5: @{sh.java.arg5}
	arg6: @{sh.java.arg6}

	on basedir: ${basedir}
		</echo>
			<java classname="@{sh.java.classname}" fork="true">
				<classpath>
					<fileset dir="@{sh.java.classpath}">
						<include name="**/*.jar" />
					</fileset>
					<dirset dir="./">
						<include name="@{sh.java.bindir}" />
					</dirset>
					<dirset dir="./" />
				</classpath>
				<!-- all arguments were given to the ant script -->
				<!-- <jvmarg value="-Xmx512m"/> -->
				<arg value="@{sh.java.arg1}" />
				<arg value="@{sh.java.arg2}" />
				<arg value="@{sh.java.arg3}" />
				<arg value="@{sh.java.arg4}" />
				<arg value="@{sh.java.arg5}" />
				<arg value="@{sh.java.arg6}" />
			</java>
		</sequential>
	</macrodef>

	<target name="sh.call.method" unless="sh.disable.call.method" description="calls a given java method">
		<property name="sh.java.classname" value="de.tsl2.nano.bean.BeanUtil" />
		<antcall target="sh.java">
		</antcall>
	</target>

	<!-- standard shell command -->
	<target name="sh.exec" unless="sh.disable.exec">
		<property name="sh.exec.dir" value="${basedir}" />
		<exec dir="${sh.exec.dir}" command="${sh.exec.command}" />
	</target>

	<!-- windows specific call to cmd.exe -->
	<target name="sh.exec.cmd">
		<property name="sh.exec.cmd.dir" value="${basedir}" />
		<property name="sh.exec.cmd.outputfile" value="${basedir}.log" />
		<property name="sh.exec.cmd.resultproperty" value="${basedir}.result" />
		<property name="sh.exec.cmd.arg1" value="" />
		<property name="sh.exec.cmd.arg2" value="" />
		<property name="sh.exec.cmd.arg3" value="" />
		<property name="sh.exec.cmd.arg4" value="" />
		<property name="sh.exec.cmd.arg5" value="" />
		<property name="sh.exec.cmd.arg6" value="" />
		<exec dir="${sh.exec.cmd.dir}" executable="cmd.exe" output="${sh.exec.cmd.outputfile}" resultproperty="${sh.exec.cmd.resultproperty}">
			<arg value="/C" />
			<arg value="${sh.exec.cmd.arg1}" />
			<arg value="${sh.exec.cmd.arg2}" />
			<arg value="${sh.exec.cmd.arg3}" />
			<arg value="${sh.exec.cmd.arg4}" />
			<arg value="${sh.exec.cmd.arg5}" />
			<arg value="${sh.exec.cmd.arg6}" />
		</exec>
	</target>

	<target name="sh.encode.base64" unless="sh.disable.encode.base64" description="encode perhaps a binary to base64-text">
		<antcall target="sh.call.method">
			<param name="arg1" value="de.tsl2.nano.core.util.FileUtil" />
			<param name="arg2" value="encodeBase64" />
		</antcall>
	</target>

	<target name="sh.decode.base64" unless="sh.disable.decode_base64" description="decode a base64-text to its original form (perhaps binary)">
		<antcall target="sh.call.method">
			<param name="arg1" value="de.tsl2.nano.core.util.FileUtil" />
			<param name="arg2" value="decodeBase64" />
		</antcall>
	</target>

	<!--
		will create xsd files from java beans.
		please define the following variables:
		  - bin.dir: reference to binary path
		  - src.gen.dir: destination directory
		  - print.base.class: class file to generate xsd from
	-->
	<target name="sh.jaxb.schemagen">
		<echo message="basedir: ${basedir}" />
		<echo message="schema-class: ${bin.dir}/${print.base.class}" />
		<echo message="output-path: ${src.gen.dir}" />
		<!-- workaround for schemagen.exe bug on java.home path containing spaces -->
		<exec dir="${sh.java.bin.dir}" executable="cmd.exe">
			<arg value="/C" />
			<arg value="echo" />
			<arg value="subst" />
			<arg value="y:" />
			<arg value="${java.home}\.." />
			<arg value=">schemagen.bat" />
		</exec>
		<exec dir="${sh.java.bin.dir}" executable="cmd.exe">
			<arg value="/C" />
			<arg value="echo" />
			<arg value="y:\bin\schemagen.exe" />
			<arg value="%1" />
			<arg value="%2" />
			<arg value="%3" />
			<arg value="%4" />
			<arg value="%5" />
			<arg value="%6" />
			<arg value=">>schemagen.bat" />
		</exec>
		<exec dir="${sh.java.bin.dir}" executable="cmd.exe">
			<arg value="/C" />
			<arg value="echo" />
			<arg value="subst" />
			<arg value="y:" />
			<arg value="/D" />
			<arg value=">>schemagen.bat" />
		</exec>

		<exec dir="${sh.java.bin.dir}" executable="cmd.exe">
			<arg value="/C" />
			<arg value="schemagen.bat" />
			<!--			<arg value="cp" />
			<arg value="./" /> -->
			<arg value="-d" />
			<arg value="${sh.java.gen.dir}" />
			<arg value="${sh.jaxb.schemagen.classname}" />
		</exec>
	</target>

	<!--
		create java bean classes from xsd (through JAXB)
	-->
	<target name="jaxb.xjc">
		<exec dir="${sh.java.res.dir}" command="xjc -d ${sh.java.gen.dir} ${sh.jaxb.xjc.classname}.xsd" />
	</target>

	<target name="sh.junit" unless="sh.disable.junit" description="do junit test on given fileset">
		<!-- fallbacks -->
		<property name="sh.junit.test.dir" value="${sh.java.test.dir}" />
		<property name="sh.junit.target.dir" value="${sh.java.target.dir}" />
		<property name="sh.junit.include" value="**/*Test.java" />
		<property name="sh.junit.jvmarg" value="-javaagent:ci/jacoco/jacocoagent.jar=destfile=${sh.junit.target.dir}ci/jacoco.exec" />

		<mkdir dir="${sh.junit.target.dir}/junit/report" />
		<sh.junit sh.junit.test.dir="${sh.junit.test.dir}" sh.junit.target.dir="${sh.junit.target.dir}" sh.junit.include="${sh.junit.include}" sh.junit.jvmarg="${sh.junit.jvmarg}" />
	</target>

	<macrodef name="sh.junit">
		<attribute name="sh.junit.test.dir" />
		<attribute name="sh.junit.target.dir" />
		<attribute name="sh.junit.include" />
		<attribute name="sh.junit.jvmarg" />

		<sequential>
			<!-- if not defined ... use fallback -->
			<echo message="doing junit on ${basedir}" />
			<property name="junittest.exclude" value="**/Base*Test.java" />

			<delete dir="${sh.junit.target.dir}/junit" failonerror="false" />
			<mkdir dir="${sh.junit.target.dir}/junit" />

			<echo>starting junit with jvmarg: ${jvmarg}</echo>
			<junit fork="true" printsummary="true" showoutput="true">
				<jvmarg value="${sh.junit.jvmarg}" />
				<classpath>
					<fileset dir="${basedir}/../">
						<include name="**/*.jar" />
						<include name="**/target/*.jar" />
					</fileset>
				</classpath>
				<formatter type="xml" />
				<batchtest todir="${sh.junit.target.dir}/junit">
					<fileset dir="@{sh.junit.test.dir}">
						<include name="@{sh.junit.include}" />
						<include name="**/*JUnit.java" />
						<exclude name="${junittest.exclude}" />
					</fileset>
				</batchtest>
			</junit>
			<!--
			<junitreport todir="${sh.junit.target.dir}/junit">
				<fileset dir="${sh.junit.target.dir}/junit">
					<include name="TEST*.xml" />
				</fileset>
				<report format="frames" todir="${sh.junit.target.dir}/junit/report" />
			</junitreport>
			<antcall target="sh.exec">
				<param name="sh.exec.dir" value="${sh.junit.target.dir}/junit/report" />
				<param name="sh.exec.command" value="index.html" />
			</antcall>
			-->
		</sequential>
	</macrodef>

	<!-- THE CODE BELOW IS UNTESTED YET -->

	<target name="sh.mail" unless="sh.disable.mail" description="send mail with attachments">
		<property name="sh.mail.user" value="testuser" />
		<property name="sh.mail.subject" value="shell-test" />
		<property name="sh.mail.host" value="mail.yahoo.com" />
		<property name="sh.mail.port" value="443" />
		<property name="sh.mail.tolist" value="${sh.mail.user}" />
		<property name="sh.mail.cclist" value="" />
		<property name="sh.mail.bcclist" value="" />
		<property name="sh.mail.attachment.dir" value="${basedir}" />
		<property name="sh.mail.attachment.include" value="**" />
		<property name="sh.mail.attachment.exclude" value="EXCLUDE" />
		<mail subject="" user="${sh.mail.user}" mailhost="${sh.mail.host}" mailport="${sh.mail.port}" tolist="${sh.mail.tolist}" cclist="${sh.mail.cclist}" bcclist="${sh.mail.bcclist}">
			<message>
				${sh.mail.message}
			</message>
			<fileset dir="${sh.mail.attachment.dir}">
				<include name="${sh.mail.attachment.include}" />
				<exclude name="${sh.mail.attachment.exclude}" />
			</fileset>
		</mail>
	</target>

	<target name="sh.telnet" unless="sh.disable.telnet" description="open a telnet session and read/write data">
		<property name="sh.telnet.server" value="localhost" />
		<property name="sh.telnet.port" value="8080" />
		<property name="sh.telnet.user" value="anonymous" />
		<property name="sh.telnet.password" value="anonymous" />
		<telnet server="${sh.telnet.server}" port="${sh.telnet.port}" userid="${sh.telnet.user}" password="${sh.telnet.password}">
		</telnet>
	</target>

	<target name="sh.wiki" unless="sh.disable.wiki" description="create html from textile-wiki">
		<property name="sh.wiki.dir" value="${basedir}" />
		<property name="sh.wiki.include" value="**/*.textile" />
		<property name="sh.wiki.exclude" value="EXCLUDE" />
		<wikitext-to-html overwrite="true">
			<fileset dir="${sh.wiki.dir}">
				<include name="${sh.wiki.include}" />
				<exclude name="${sh.wiki.exclude}" />
			</fileset>
		</wikitext-to-html>
	</target>

	<target name="sh.xml.validate" unless="sh.disable.validate" description="validate an xml file">
		<property name="sh.xml.validate.srcdir" value="${basedir}" />
		<property name="sh.xml.validate.include" value="**" />
		<property name="sh.xml.validate.exclude" value="EXCLUDEEXPRESSION" />
		<xmlvalidate>
			<fileset dir="${sh.xml.validate.srcdir}">
				<include name="${sh.xml.validate.include}" />
				<exclude name="${sh.xml.validate.exclude}" />
			</fileset>
		</xmlvalidate>
	</target>

	<target name="sh.xml.xpath" unless="sh.disable.xml.xpath" description="do an xpath query">
		<!--		<property name="arg3" value="shell.xml" />
		<property name="arg4" value="count(//target)" /> -->
		<antcall target="sh.call.method">
			<param name="arg1" value="de.tsl2.nano.core.util.XmlUtil" />
			<param name="arg2" value="xpath" />
			<param name="arg3" value="${sh.xml.xpath.file}" />
			<param name="arg4" value="${sh.xml.xpath.expression}" />
		</antcall>
	</target>

	<target name="sh.xml.xslt" unless="sh.disable.xslt" description="do xsl transformations on xml files">
		<property name="sh.xml.xslt.style" value="transform.xsl" />
		<property name="sh.xml.xslt.dir" value="${basedir}" />
		<property name="sh.xml.xslt.include" value="**/*.xml" />
		<property name="sh.xml.xslt.destdir" value="generated" />
		<xslt style="${sh.xml.xslt.style}" basedir="${sh.xml.xslt.dir}" includes="${sh.xml.xslt.include}" destdir="${sh.xml.xslt.destdir}">
		</xslt>
	</target>

	<target name="sh.xml.velocity" unless="sh.disable.velocity" description="do velocity transformations with template and object infos">
		<property name="sh.xml.velocity.template" value="template.vm" />
		<antcall target="sh.call.method">
			<param name="arg1" value="de.tsl2.nano.core.util.XmlUtil" />
			<param name="arg2" value="transform" />
			<param name="arg3" value="${sh.xml.velocity.template}" />
		</antcall>
	</target>

	<target name="sh.foreach" unless="sh.disable.foreach" description="executes a shell command for a given fileset">
		<!-- fallbacks -->
		<antcall target="sh.input">
			<param name="sh.input.name" value="sh.foreach.command" />
		</antcall>
		<echo message="sh.foreach.command: ${sh.foreach.command}" />
		<property name="sh.foreach.dir" value="${basedir}" />
		<property name="sh.foreach.type" value="file" />
		<property name="sh.foreach.output" value="foreach.log" />
		<property name="sh.foreach.arg1" value="" />
		<property name="sh.foreach.arg2" value="" />
		<property name="sh.foreach.arg3" value="" />
		<property name="sh.foreach.arg4" value="" />
		<property name="sh.foreach.arg5" value="" />
		<property name="sh.foreach.arg6" value="" />
		<property name="sh.foreach.include" value="**" />
		<property name="sh.foreach.include2" value="INCLUDING_EXPRESSION" />
		<property name="sh.foreach.include3" value="INCLUDING_EXPRESSION" />
		<property name="sh.foreach.include4" value="INCLUDING_EXPRESSION" />
		<property name="sh.foreach.exclude" value="EXCLUDING_EXPRESSION" />
		<property name="sh.foreach.exclude2" value="EXCLUDING_EXPRESSION2" />
		<property name="sh.foreach.exclude3" value="EXCLUDING_EXPRESSION3" />
		<property name="sh.foreach.exclude4" value="EXCLUDING_EXPRESSION3" />
		<echo>writing output to: ${sh.foreach.output}</echo>
		<!-- start it -->
		<sh.foreach sh.foreach.dir="${sh.foreach.dir}" sh.foreach.command="${sh.foreach.command}" sh.foreach.type="${sh.foreach.type}" sh.foreach.output="${sh.foreach.output}" sh.foreach.arg1="${sh.foreach.arg1}" sh.foreach.arg2="${sh.foreach.arg2}" sh.foreach.arg3="${sh.foreach.arg3}" sh.foreach.arg4="${sh.foreach.arg4}" sh.foreach.arg5="${sh.foreach.arg5}" sh.foreach.arg6="${sh.foreach.arg6}" sh.foreach.include="${sh.foreach.include}" sh.foreach.include2="${sh.foreach.include2}" sh.foreach.include3="${sh.foreach.include3}" sh.foreach.include4="${sh.foreach.include4}" sh.foreach.exclude="${sh.foreach.exclude}" sh.foreach.exclude2="${sh.foreach.exclude2}" sh.foreach.exclude3="${sh.foreach.exclude3}" sh.foreach.exclude4="${sh.foreach.exclude4}" />
	</target>

	<!-- defining a macro to be able to call it multiple times -->
	<macrodef name="sh.foreach" description="executes a shell command for a given fileset">
		<attribute name="sh.foreach.dir" />
		<attribute name="sh.foreach.command" />
		<attribute name="sh.foreach.type" />
		<attribute name="sh.foreach.output" />
		<attribute name="sh.foreach.arg1" />
		<attribute name="sh.foreach.arg2" />
		<attribute name="sh.foreach.arg3" />
		<attribute name="sh.foreach.arg4" />
		<attribute name="sh.foreach.arg5" />
		<attribute name="sh.foreach.arg6" />
		<attribute name="sh.foreach.include" />
		<attribute name="sh.foreach.include2" />
		<attribute name="sh.foreach.include3" />
		<attribute name="sh.foreach.include4" />
		<attribute name="sh.foreach.exclude" />
		<attribute name="sh.foreach.exclude2" />
		<attribute name="sh.foreach.exclude3" />
		<attribute name="sh.foreach.exclude4" />

		<sequential>
			<apply executable="@{sh.foreach.command}" type="@{sh.foreach.type}" logerror="true" output="@{sh.foreach.output}">
				<arg value="@{sh.foreach.arg1}" />
				<arg value="@{sh.foreach.arg2}" />
				<arg value="@{sh.foreach.arg3}" />
				<arg value="@{sh.foreach.arg4}" />
				<arg value="@{sh.foreach.arg5}" />
				<arg value="@{sh.foreach.arg6}" />
				<srcfile />
				<fileset dir="@{sh.foreach.dir}">
					<include name="@{sh.foreach.include}" />
					<include name="@{sh.foreach.include2}" />
					<include name="@{sh.foreach.include3}" />
					<include name="@{sh.foreach.include4}" />
					<exclude name="@{sh.foreach.exclude}" />
					<exclude name="@{sh.foreach.exclude2}" />
					<exclude name="@{sh.foreach.exclude3}" />
					<exclude name="@{sh.foreach.exclude4}" />
				</fileset>
			</apply>
		</sequential>
	</macrodef>

	<target name="sh.disassemble">
		<antcall target="sh.foreach">
			<param name="sh.foreach.command" value="javap" />
			<param name="sh.foreach.arg1" value="-v" />
			<param name="sh.foreach.arg2" value="-c" />
			<param name="sh.foreach.arg3" value="-p" />
			<param name="sh.foreach.arg4" value="-constants" />
			<param name="sh.foreach.include" value="**/*.class" />
			<param name="sh.foreach.output" value="disassemble.txt" />
		</antcall>
		<!--		<apply executable="javap" type="file" logerror="true" output="disassemble.txt">
			<arg value="-v"/>
			<arg value="-c"/>
			<arg value="-p"/>
			<arg value="-constants"/>
			<srcfile/>
			<fileset dir="${basedir}">
				<include name="**/*.class"/>
			</fileset>
		</apply>
		-->
	</target>

	<!-- <target name="sh.build.timestamp">
		<buildnumber file="${sh.build.property.file}"/>
	</target>-->
	<target name="sh.build" unless="sh.disable.build" depends="sh.printinfo" description="do a standard java build">
		<!-- fallbacks -->
		<property name="sh.build.basedir" value="${basedir}" />
		<property name="sh.build.name" value="${sh.build.basedir}" />
		<property name="sh.build.version" value="${sh.java.build.version}-${tstamp}" />
		<property name="sh.build.src" value="${sh.build.basedir}/src/main" />
		<property name="sh.build.lib" value="${sh.build.basedir}/lib" />
		<property name="sh.build.bin" value="${sh.build.basedir}/bin" />
		<property name="sh.build.debug" value="false" />
		<property name="sh.junit.jvmarg" value="-javaagent:ci/jacoco/jacocoagent.jar=destfile=ci/jacoco.exec" />
		
		<!-- store build informations to build.properties -->
		<buildnumber file="${sh.build.basedir}/src/resources/build-${sh.build.name}.properties" />
		<propertyfile file="${sh.build.basedir}/src/resources/build-${sh.build.name}.properties">
			<entry key="build.name" value="${sh.build.name}" />
			<entry key="build.debug" value="${sh.build.debug}" />
			<entry key="build.version" value="${sh.build.version}" />
			<entry key="build.time" value="${tstamp}" />
			<entry key="build.user" value="${user.name}" />
			<entry key="build.java" value="${java.runtime.version}" />
		</propertyfile>

		<!-- create binaries -->
		<antcall target="sh.compile">
			<param name="sh.compile.srcdir" value="${sh.build.src}" />
			<param name="sh.compile.srcdir2" value="${sh.build.basedir}/src/resources" />
			<param name="sh.compile.bindir" value="${sh.build.bin}" />
			<param name="sh.compile.classpath" value="${sh.build.lib}" />
			<param name="sh.compile.debug" value="${sh.build.debug}" />
			<param name="sh.compile.extdirs" value="${sh.build.extdirs}" />
		</antcall>
		<!-- The standard jdk-compiler wont copy resource files from src to bin-directory -->
		<antcall target="sh.copy">
			<param name="sh.copy.srcdir" value="${sh.build.src}" />
			<param name="sh.copy.destination" value="${sh.build.bin}" />
			<param name="sh.copy.exclude" value="**/*.java" />
		</antcall>
		<!--		<antcall target="sh.copy">
			<param name="sh.copy.srcdir" value="${sh.compile.srcdir2}" />
			<param name="sh.copy.destination" value="${sh.build.bin}" />
			<param name="sh.copy.exclude" value="**/*.java*" />
		</antcall>
		<antcall target="sh.copy">
			<param name="sh.copy.srcdir" value="${sh.compile.srcdir3}" />
			<param name="sh.copy.destination" value="${sh.build.bin}" />
			<param name="sh.copy.exclude" value="**/*.java*" />
		</antcall>-->

		<!--		<antcall target="sh.wiki">
			<param name="sh.wiki.srcdir" value="${sh.build.basedir}" />
			<param name="sh.wiki.include" value="**/*.textile" />
		</antcall> -->

		<antcall target="sh.jar">
			<param name="sh.jar.srcdir" value="${sh.build.bin}" />
			<param name="sh.jar.destination" value="${sh.build.basedir}/${sh.java.target.dir}/${sh.build.name}.${sh.build.version}.jar" />
			<param name="sh.jar.manifest" value="${sh.build.basedir}/META-INF/MANIFEST.MF" />
		</antcall>

		<!-- TODO: key parameter -->
		<!-- using key:
		keytool -genkey -keystore tsl2store -alias tsl2
		passwd: tsl2tsl2, name: tsl2, surname: tsl2, orga: tsl2 -->
		<signjar alias="tsl2"  keystore="../tsl2.nano.incubation/tsl2store"  storepass="tsl2tsl2"  jar="${sh.build.basedir}/${sh.build.name}.${sh.build.version}.jar">
		</signjar>
		
		<!-- source-jar -->
		<antcall target="sh.jar">
			<param name="sh.jar.srcdir" value="${sh.build.basedir}" />
			<param name="sh.jar.destination" value="${sh.build.basedir}/${sh.java.target.dir}/${sh.build.name}.${sh.build.version}.src.jar" />
			<param name="sh.jar.exclude" value="**/bin/**" />
			<param name="sh.jar.exclude2" value="**/*.*ar" />
			<param name="sh.jar.exclude3" value="**/*.zip" />
			<param name="sh.jar.exclude3" value="**/target/**" />
		</antcall>
	</target>

	<!-- calls the sh.build target after clean, runs junit tests -->
	<target name="sh.build.full" depends="sh.clean, sh.build, sh.junit">
	</target>
</project>
