<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><p><strong>NanoFix.ServiceAccess</strong><br/><font size="-1">Autor: Thomas Schneider 2009-2012</font></p><ol style="list-style: none;"><li><a href="#Introduction">Introduction</a><ol style="list-style: none;"><li><a href="#UsingondifferentApplicationServers">Using on different Application Servers</a></li></ol></li><li><a href="#Features">Features</a><ol style="list-style: none;"><li><a href="#QuickStart">Quick Start</a></li></ol></li><li><a href="#Initializing">Initializing</a><ol style="list-style: none;"><li><a href="#Settingserverconnections">Setting server connections</a><ol style="list-style: none;"><li><a href="#JBoss46andOracle1011">JBoss 4-6 and Oracle 10-11</a></li></ol></li><li><a href="#CreatingtheLoginModule">Creating the LoginModule</a></li></ol></li><li><a href="#UsingtheFeatureandServiceFactory">Using the Feature- and ServiceFactory</a></li><li><a href="#OptionalFeatureIntegrationonRuntime">Optional Feature Integration on Runtime</a></li><li><a href="#EntitiesandServices">Entities and Services</a><ol style="list-style: none;"><li><a href="#UsingServicesperformanceaspects">Using Services - performance aspects</a></li><li><a href="#TheGenericService">The GenericService</a><ol style="list-style: none;"><li><a href="#SupportforcomplexqueriesthroughacollectionoffindersImplementationofIQueryService">Support for complex queries through a collection of finders: Implementation of _IQueryService_</a></li><li><a href="#TheCachingBatchloadermechanism">The Caching Batchloader mechanism</a></li><li><a href="#HowtoincludetheGenericServiceintoyourproject">Howto include the GenericService into your project</a></li></ol></li></ol></li><li><a href="#JobScheduleService">JobScheduleService</a><ol style="list-style: none;"><li><a href="#HowtoincludetheGenericServiceinyourproject">Howto include the GenericService in your project</a></li><li><a href="#SecurityAuthorizationonPermissions">Security / Authorization on Permissions</a></li><li><a href="#CreatingownEntitiesandServices">Creating own Entities and Services</a></li></ol></li><li><a href="#developinganddeploying">developing and deploying</a></li></ol><h2 id="Introduction">Introduction</h2><p>This project provides implementations to access services through a <a href="src/main/de.tsl2.nano/serviceaccess/ServiceFactory.java">servicefactory</a>. The JAAS is used to do authentification and authorization (see: <a href="src/main/de.tsl2.nano/serviceaccess/aas/module/AbstractLoginModule.java">here</a>). A feature-mechanism provides the possibility to do optional calls to feature-implementations. </p><p>For further informations, see here: </p><ul><li><a href="http://java.sun.com/j2se/1.4.2/docs/guide/security/jaas/tutorials/GeneralAcnAndAzn.html">Java Sun Tutorial</a></li><li><a href="http://www.oio.de/public/java/jaas/sso-jaas-kerberos-tutorial.htm">Short Tutorial</a> mit Sequenz-Diagrammen.</li></ul><h3 id="UsingondifferentApplicationServers">Using on different Application Servers</h3><p>This plugins contains some jboss specific api jars:</p><ul><li>jboss-ejb-api_3.1_spec.jar</li><li>jboss-interceptors-api_1.1_spec.jar</li><li>hibernate-jpa-2.0-api.jar</li></ul><p>To use the plugin inside another appserver like glassfish, you should remove the file names from MANIFEST.MF. Your applications MANIFEST.MF should include the desired appserver-lib plugin as dependency &#8211; before the serviceaccess plugin.</p><h2 id="Features">Features</h2><ul><li><a href="src/main/de.tsl2.nano/serviceaccess/ServiceFactory.java">ServiceFactory</a> <ul><li>service provider using a <a href="src/main/de.tsl2.nano/serviceaccess/ServiceLocator.java">ServiceLocator</a> and a <a href="src/main/de.tsl2.nano/serviceaccess/ServiceProxy.java">ServiceProxy</a></li><li>holds a user session with current user, mandator and mandator-dependent features</li></ul></li><li><a href="src/main/de.tsl2.nano/serviceaccess/aas/AbstractLoginModule.java">AbstractLoginModule</a> java <strong>aas</strong> access with permissions, roles and principals.</li><li><a href="src/main/de.tsl2.nano/service/feature/FeatureFactory.java">FeatureFactory</a> enables optional calling of feature implementations </li><li><a href="src/main/de.tsl2.nano/service/util/IGenericLocalService.java">GenericService</a> provides standard bean service access methods<ul><li>Implementation of IQueryService provides support for complex queries, defining a collection of finders.</li></ul></li><li>PersistenceUtil: some persistence utility methods</li><li>ServiceUtil: some query helper methods</li><li><a href="src/main/de.tsl2.nano/service/util/BeanContainerUtil.java">BeanContainerUtil</a> bridge for framework standard bean service actions (delegates to  GenericServiceBean)</li><li><a href="src/main/de.tsl2.nano/service/schedule/IJobScheduleService.java">JobScheduleServiceBean</a> provides ejb 3.1 timer service access.</li><li><a href="fsconnector.html">FileSystem-Connector</a> simple filesystem connector implementation. a simple <a href="src/main/de.tsl2.nano/service/util/FileServiceBean.java">FileService</a> simplifies the use. have a look at the junit-test <a href="src/test/de/idvag/serviceaccess/test/FileServiceTest.java">FileServiceTest</a> to see some use-cases.c</li><li>CachingBatchLoader: is able to load data in a block, doing minimal communication with the server. second feature is optional storing that loaded data providing it as cache for the application.</li></ul><h3 id="QuickStart">Quick Start</h3><p>To see, how to use the the services in the simpliest way, have a look at the test class <a href="src/test/de/idvag/serviceaccess/test/ServiceAccessTest.java">ServiceAccessTest</a>.</p><h2 id="Initializing">Initializing</h2><p>The project depends on an ejb implementation. without a dependency to library project, holding and exporting a library like &#8216;javaee.jar&#8217;, it isn&#8217;t compilable.</p><p>The ServiceFactory as the main object of this package must be initialized to use the right classloader. You do that calling the <em>ServiceFactory.createInstance(...)</em> method.<br><br/>To use user-session informations and authorization and mandator-dependend features. The call of <em>ServiceFactory.instance().createSession(...)</em> is neccessary. You will implement an own AAS LoginModule class to do the call on client side. On server side, a service method, doing the authentication and authorization should call that, too.</p><h3 id="Settingserverconnections">Setting server connections</h3><p>For developing the applicationserver will be started in default-mode, using the localhost. The database connection will be done through a datasource-connection, defined inside the applicationserver. To change the connections to the application-server or database, read the following descriptions.</p><h4 id="JBoss46andOracle1011">JBoss 4-6 and Oracle 10-11</h4><ul><li>to start jboss for a given network-ip and a given mode:<ul><li><i>./run.sh -cminimal --host 192.168.56.102</i></li><li>change jndi (<i>jndi-jboss.properties</i>) on shared-plugin: <i>java.naming.provider.url=jnp://192.168.56.102:1099</i></li><li>change jndi (<i>jndi-jboss.properties</i>) on jboss-plugin : <i>java.naming.provider.url=jnp://192.168.56.102:1099</i></li></ul></li><li>to change the database-connection or your app-server, edit the deployed file oracle-ds.xml:<ul><li>e.g.: connection-url: <i>jdbc:oracle:thin:@localhost:1521:xe</i></li></ul></li><li>to change the local test-data db-connection (see <i>create.db.test</i>), edit <i>oradb-connection.properties</i> </li></ul><h3 id="CreatingtheLoginModule">Creating the LoginModule</h3><p>overwrite the class <em>AbstractLoginModule</em> to define the authentication and authorization.</p><p>Example:<br/><pre><br/>/**<br/> * <br/> * @author Thomas Schneider, Thomas Schneider, www.idv-ag.de<br/> * @version $Revision$<br/> */<br/>public class LoginModule extends AbstractLoginModule {<br/>    protected boolean authenticate() throws FailedLoginException {<br/>        IBenutzerService benutzerService = ServiceFactory.instance().getService(IBenutzerService.class);<br/>        Benutzer b;<br/>        if (password1 == null)<br/>            b = benutzerService.authenticate(username, String.valueOf(password));<br/>        else<br/>            //password changing<br/>            b = benutzerService.changePasswd(username,<br/>                String.valueOf(password),<br/>                String.valueOf(password1),<br/>                String.valueOf(password2));<br/>        if (b == null)<br/>            throw new FailedLoginException(Messages.getString(&#8220;swartifex.login.error.userorpasswd&#8221;));</p>       //create the mandator dependend features
        Mandant mandant = benutzerService.getMandant();
        Collection<String> mandatorModules = benutzerService.getMandatorFeatures();
        ServiceFactory.instance().createSession(b, mandant, subject, null, mandatorFeatures, null);       return b != null;
    }   /**
     * {@inheritDoc}
     */
    @Override
    protected void authorize() {
        super.authorize();       //add all user roles as principals
        IBenutzerService benutzerService = ServiceFactory.instance().getService(IBenutzerService.class);
        Collection<String> userRoles = benutzerService.getUserRoles(username);
        for (String roleName : userRoles) {
            subject.getPrincipals().add(new Role(roleName));
        }
        LOG.info(&#8220;logged-in-user:\n&#8221; + subject);
    }
 }
</pre><h2 id="UsingtheFeatureandServiceFactory">Using the Feature- and ServiceFactory</h2><p>Use the following methods, to work with the service factory:</p><ul><li>ServiceFactory:<ul><li>ServiceFactory.instance().getService(serviceInterface)</li><li>ServiceFactory.instance().getUserObject()</li><li>ServiceFactory.instance().getMandatorObject()</li></ul></li><li>FeatureFactory:<ul><li>FeatureFactory.instance().getImpl(featureInterface).featureMethod(...)</li></ul></li></ul><p><strong>Tip:</strong><br/>Have a look into the log file (after user login) to see, which roles and features are assigned. The feature names will be compared case-sensitive!</p><p><strong>WARNING</strong><br/>Do not use the ServiceFactory inside server-side service implementations! To get services<br/>on server side, use EJB conventions.<br/>Example:<br/><pre><br/>@EJB<br/>IGenericLocalService genService<br/></pre></p><h2 id="OptionalFeatureIntegrationonRuntime">Optional Feature Integration on Runtime</h2><p>The description will be found here:<br/><a href="..\swartifex\doc\readme.txt.html#4.14">4.14 Optional Feature Integration on Runtime</a></p><h2 id="EntitiesandServices">Entities and Services</h2><h3 id="UsingServicesperformanceaspects">Using Services &#8211; performance aspects</h3><p>If you call a service, you use an interface definition to define the service bean. On client side calls, you will use a remote interface &#8211; an expensive communication (RMI or Corba) to the remote vm will be done, serializing transferred data. on server side calls you use a local interface &#8211; no serializing and no communication has to be done.</p><h3 id="TheGenericService">The GenericService</h3><p>The <a href="src/main/de.tsl2.nano/service/util/IGenericService.java">GenericService</a> is an EJB 3 stateless Session Bean providing the following methods:</p><p><pre><br/>    /** find all beans of type beanType (statement cache will be used!) */<br/>    public <T> Collection<T> findAll(Class<T> beanType, Class... lazyRelations);</p>   /**
     * find all beans of type beanType (statement cache will be used!)
     * 
     * @param <T> bean type
     * @param beanType bean type
     * @param maxResult (optional: set -1 to use no definition) maximum result count
     * @param lazyRelations (optional) pre-loaded lazy-relation types
     * @return filled collection with beans of type beantype
     */
    public <T> Collection<T> findAll(Class<T> beanType, int maxResult, Class... lazyRelations);   /**
     * find all beans of type beanType beeing members of holder. useful if your beanType has no access to the holder.
     * <p>
     * 
     * <pre>
     * f.e.: 
     *   Parent (1) &lt;-- (*) Child
     *   ==&gt; but you want to get the parents children!
     * will result in:
     *   select t from Child t, Parent t1 
     *   where t1.ID = holder.ID 
     *   and t member of t1.{attributeName}
     * </pre>
     * 
     * @param <H> holder type
     * @param <T> member type
     * @param beanType member type to be collected
     * @param holder holder instance to get the members of (without direct access!)
     * @param attributeName
     * @return members of holder (member given by attributeName)
     */
    &lt;H, T&gt; Collection<T> findMembers(H holder, Class<T> beanType, String attributeName, Class... lazyRelations);   /**
     * find all holders of the given member instance. useful if your member has no access to the holder. on composites
     * and aggregations you will get a collection holding only one instance.
     * <p>
     * 
     * <pre>
     * f.e.: 
     *   Parent (1) --&gt; (*) Child
     *   ==&gt; but you want to get a childs parent!
     * will result in:
     *   select t from Child t, Parent t1 
     *   where t.ID = member.ID 
     *   and t member of t1.{attributeName}
     * </pre>
     * 
     * @param <H> holder type
     * @param <T> member type
     * @param beanType member type to be collected
     * @param holder holder instance to get the members of (without direct access!)
     * @param attributeName
     * @return members of holder (member given by attributeName)
     */
    &lt;H, T&gt; Collection<H> findHolders(T member, Class<H> holderType, String attributeName, Class... lazyRelations);   /**
     * tries to find the given bean &#8211; if more than one bean was found, an exception will be thrown.
     * 
     * @param <T> bean type
     * @param exampleBean example bean
     * @return exactly one bean!
     */
    <T> T findByExample(T exampleBean, Class... lazyRelations);   /** find all beans with same attributes (only single value attributes!) as exampleBean */
    public <T> Collection<T> findByExample(T exampleBean, boolean caseInsensitive, Class... lazyRelations);   /** find all beans with similar (like) attributes (only single value attributes!) as exampleBean */
    public <T> Collection<T> findByExampleLike(T exampleBean, boolean caseInsensitive, Class... lazyRelations);   /** find bean with given id */
    public <T> T findById(Class<T> beanType, Object id, Class... lazyRelations);   /** find all beans with same attributes (only single value attributes!) between first and second bean */
    public <T> Collection<T> findBetween(T firstBean, T secondBean, boolean caseInsensitive, Class... lazyRelations);   /**
     * finds all beans, having properties between firstBean and secondBean.
     * 
     * @param <T> beantype
     * @param firstBean minimum bean
     * @param secondBean maximum bean
     * @param caseInsensitive whether to search strings case insensitive
     * @param maxResult (optional: set -1 to use no definition) maximum result count
     * @param lazyRelations (optional) pre-loaded lazy-relation types
     * @return filled collection with beans of type T
     */
    public <T> Collection<T> findBetween(T firstBean,
            T secondBean,
            boolean caseInsensitive,
            int maxResult,
            Class... lazyRelations);   /**
     * find items by query. args are optional. if nativeQuery is true, a standard sql-query will be done
     * 
     * @param queryString may be a jpa-ql (nativeQuery=false!) or sql string (nativeQuery=true)
     * @param nativeQuery should only be true, if you use pure sql
     * @param args if your queryString contains parameters (represented by questionmarks (&#8216;?&#8217;), they will be
     *            sequentially filled with the values of args
     * @param lazyRelations (optional) one-to-many types to be filled before returning
     * @return result of query
     */
    public Collection&lt;?&gt; findByQuery(String queryString, boolean nativeQuery, Object[] args, Class... lazyRelations);   /**
     * find items by query. args are optional. if nativeQuery is true, a standard sql-query will be done
     * 
     * @param queryString may be a jpa-ql (nativeQuery=false!) or sql string (nativeQuery=true)
     * @param nativeQuery should only be true, if you use pure sql
     * @param args if your queryString contains parameters (represented by &#8216;:&#8217; + varname (e.g. :myvar), they will be
     *            filled with the values of args
     * @param lazyRelations (optional) one-to-many types to be filled before returning
     * @return result of query
     */
    public Collection&lt;?&gt; findByQuery(String queryString,
            boolean nativeQuery,
            Map&lt;String, ?&gt; args,
            Class... lazyRelations);   /**
     * find one item by query. args are optional. if nativeQuery is true, a standard sql-query will be done. for further
     * informations, see {@link #findByQuery(String, boolean, Object[], Class...)}.
     */
    public Object findItemByQuery(String queryString, boolean nativeQuery, Object[] args, Class... lazyRelations);   /**
     * find one value by query &#8211; fast way to get a single value like through &#8216;count(*)&#8217; without packing it to a bean. 
     * BE SURE TO RETURN EXACTLY ONE VALUE! Little bit faster than {@link #findItemByQuery(String, boolean, Object[], Class...)}.
     * args are optional. if nativeQuery is true, a standard sql-query will be done. for further
     * informations, see {@link #findByQuery(String, boolean, Object[], Class...)}.
     */
    public Object findValueByQuery(String queryString, boolean nativeQuery, Object... args);   /**
     * persists or merges the given object &#8211; committing a transaction and calling refresh and flush after.
     * {@link #persistNoTransaction(Object, boolean, boolean)} to work on bean-managed transactions
     */
    public <T> T persist(T bean, Class... lazyRelations);   /**
     * persists or merges the given object &#8211; committing a transaction. if refresh and flush are false, you have a high
     * performance. use {@link #persistNoTransaction(Object, boolean, boolean)} to work on bean-managed transactions
     */
    public <T> T persist(T bean, boolean refreshBean, boolean flush, Class... lazyRelations);   /**
     * persists or merges the given object without accessing a transaction. if refresh and flush are false, you have a
     * high performance.
     */
    public <T> T persistNoTransaction(T bean, boolean refreshBean, boolean flush, Class... lazyRelations);   /** persists or merges the objects of the given collection &#8211; using one transaction. */
    public <T> Collection<T> persistCollection(Collection<T> beans, Class... lazyRelations);   /** refreshes the given object &#8211; reloads it in the current transaction / session! */
    public <T> T refresh(T bean);   /** removes the given object */
    public void remove(Object bean);   /**
     * calls any method on the relation to invoke an instantiation of the given relation. this can&#8217;t be done on a bean,
     * that was already serialized, so we have to get a &#8216;fresh&#8217; source bean to call any method on the given attribute.
     * <p>
     * WARNING: only useful on calling remote interfaces, where serialization will be done! if you call a service on the
     * same jvm, you should use the IGenericLocalService &#8211; and the {@link #instantiateLazyRelationship(Object)} is
     * obsolete.
     * 
     * 
     * @param <T> type of bean
     * @param clazz type of source bean
     * @param beanId id of source bean
     * @param attributes optional relation attributes to instantiate. if null, all attributes will be instantiated.
     * @return new bean with given id.
     */
    public <T> T instantiateLazyRelationship(Class<T> clazz, Object beanId, String[] attributes);   /**
     * calls any method on the relation to invoke an instantiation of the given relation. this can&#8217;t be done on a bean,
     * that was already serialized, so we have to get a &#8216;fresh&#8217; source bean to call any method on the given attribute.
     * <p>
     * WARNING: works recursive! max recurs level is 10. if fillTypes is null, only the attributes of the current bean
     * will be instantiated. if fillTypes is not null, all other relations will be evaluated through all its attributes!
     * All beans will only be instantiated once!
     * <p>
     * WARNING: only useful on calling remote interfaces, where serialization will be done! if you call a service on the
     * same jvm, you should use the IGenericLocalService &#8211; and the {@link #instantiateLazyRelationship(Object)} is
     * obsolete.
     * 
     * 
     * @param <T> type of bean
     * @param clazz type of source bean
     * @param beanId id of source bean
     * @param fillTypes optional relation types to instantiate. if null, all attributes will be instantiated.
     * @return new bean with given id.
     */
    public <T> T instantiateLazyRelationship(Class<T> clazz, Object beanId, List<Class> fillTypes);   /**
     * convenience method for {@linkplain #instantiateLazyRelationship(Class, Object, String[])}. using reflection on
     * id-annotation to get the id. if not implemented, it will throw a notimplemented exception &#8211; then use
     * {@linkplain #instantiateLazyRelationship(Class, Object, String[])} instead.
     * <p>
     * WARNING: only useful on calling remote interfaces, where serialization will be done! if you call a service on the
     * same jvm, you should use the IGenericLocalService &#8211; and the {@link #instantiateLazyRelationship(Object)} is
     * obsolete.
     * 
     * @param <T> type of bean
     * @param bean bean instance with unloaded lazy relations.
     * @return bean instance with loaded relations.
     */
    public <T> T instantiateLazyRelationship(T bean);   /**
     * tries to find the right user entity through the user principal
     * 
     * @param <T> user entitiy
     * @param subject current subject
     * @param userEntity user entity type
     * @param userIdAttribute user name attribute
     * @return bean representing current subject
     */
    public <T> T getUser(Subject subject, Class<T> userEntity, String userIdAttribute);   /**
     * only for tests &#8211; creates an empty server side factory.
     */
    void initServerSideFactories();
</pre><p>The service may be used inside your business services, but may be called directly by the client &#8211; but do that only, if you call the service once and the call is not usable by another business logic.</p><p>The service is usable by standalone applications (without application-server), too. The <i>persistence.xml</i> will define the behaviour of the sessions <i>EntityManager</i> with caching and logging etc.</p><p>An optional configuration file <i>genericservice.properties</i> will be loaded by the <i>GenericServiceBean</i> (the implementation of <i>IGenericService</i>). The following properties will be evaluated:</p><ul><li>maxresult (default: 10000)</li></ul><p>If you are on client side, use the ServiceFactory to get the GenericServiceBean.<br/>Example:<br/>  ServiceFactory.instance().getService(IGenericService.class)<br/>or<br/>  ServiceFactory.getGenService()</p><p>If you are on server side, use EJB injection:<br/><pre><br/>@EJB<br/>IGenericLocalService genService<br/></pre></p><h4 id="SupportforcomplexqueriesthroughacollectionoffindersImplementationofIQueryService">Support for complex queries through a collection of finders: Implementation of <em>IQueryService</em></h4><p>The GenericServiceBean implements the <em>IQueryService</em>:</p><p><pre><br/>/**<br/> * Provides finder expression &#8211; instead of sql or ejb-ql. Additional ejb-ql-queries are possible. Finder expressions<br/> * will automatically create ejb-ql expressions through given transient bean instances.<br/> * <p/><br/> * Combines multiple findBy-Expressions to create a complex query. Similar to criterias but working on intelligent<br/> * finders. At the moment, all concatenations are added with AND.<br/> * <br/> * @author Thomas Schneider, Thomas Schneider<br/> * @version $Revision$<br/> */<br/>public interface IQueryService {<br/>    /**<br/>     * combines several find-expressions, like findByExample and findBetween etc., to create complex queries through<br/>     * bean-attribute informations.<br/>     * <br/>     * @param <T> type to return<br/>     * @param finder several finders to constrain the result<br/>     * @return query result as list of beans<br/>     */<br/>    &lt;FINDER extends AbstractFinder<T>, T&gt; java.util.Collection<T> find(FINDER... finder);<br/>}<br/></pre></p><p>The method <strong>find(FINDER...finder)</strong> enhances the use of finders like <em>findBetween(..)</em> and <em>findExample(..)</em>. You are able to define a collection of such finders to create a complex ejb-ql.</p><p><strong>Example, showing all finders &#8211; but with senseless Example-Objects</strong>:<br/><pre><br/>...<br/>import static de.tsl2.nano.service.util.finder.Finder.*;<br/>...<br/>/*<br/> * first, create some example objects<br/> */<br/>    Person p1 = new Person(&#8220;test&#8221;, DateUtil.getDate(1970, 1, 1), new Address(&#8220;Berlinerstr.1&#8221;,<br/>        &#8220;Frankfurt&#8221;));<br/>    Person p2 = new Person(&#8220;test&#8221;, DateUtil.getDate(1979, 12, 31), new Address(&#8220;Berlinerstr.1&#8221;,<br/>        &#8220;Frankfurt&#8221;));<br/>    Team team = new Team(&#8220;team1&#8221;, new ListSet(p1, p2));</p><p>/*<br/> * now, define a query through a collection of finders &#8211; it&#8217;s only a senseless example,<br/> * showing almost all finders.<br/> */<br/>    Collection<Person> result = ServiceAccess.getGenService().find(<br/>        between(p1, p2),<br/>        or(example(p1)),<br/>        or(member(team, Person.class, &#8220;player&#8221;)),<br/>        not(expression(Person.class, &#8220; myfield = myVariable &#8221;, false, null)),<br/>        union(Person.class),<br/>        holder(p1, Team.class, &#8220;player&#8221;),<br/>        orderBy(Person.class, &#8220;+name&#8221;, &#8220;-birthday&#8221;));<br/></pre></p><p>The select, given to a Query of the ejb EntityManager would look like this:<br/><pre><br/>select t from Person t <br/> where  ( t.address  &gt;= ? and t.address  &lt;= ? )  and  ( t.birthday  &gt;= ? and t.birthday  &lt;= ? ) <br/>  or   t in (select t1 from Person t1 <br/> where t1.address = ? and t1.birthday = ?)<br/>  or   t in (select t2 from Person t2 , Team tm2<br/> where (tm2.name = ? and t2 member of tm2.player))<br/> and not  ( myfield = myVariable )<br/>union select t from Person t <br/> where 1 = 1<br/>  and   t in (select t5 from Person t5 , Person th5<br/> where (th5.name = ? and th5 member of t5.player))<br/> order by name asc, birthday desc<br/></pre><br/>The parameters will automatically be filled.</p><p><strong>A real working example:</strong><br/><pre><br/>    /*<br/>     * fuege zusaetzliche such-Felder als Example-Objekte an<br/>     */<br/>    if (sfrom.getStnr() != null) {<br/>        Steuerfall minSteuerfall = new Steuerfall();<br/>        String minStnr = StringUtilBase.fixString(sfrom.getStnr(), 13, &#8216;0&#8217;, true);<br/>        minSteuerfall.setStnr(SteuerakteUtil.getFormattedStnrAsLong(minStnr));<br/>        wvFrom.setSteuerfall(minSteuerfall);</p>       Steuerfall maxSteuerfall = new Steuerfall();
        String maxStnr = StringUtilBase.fixString(sfrom.getStnr(), 13, &#8216;9&#8217;, true);
        maxSteuerfall.setStnr(SteuerakteUtil.getFormattedStnrAsLong(maxStnr));
        wvTo.setSteuerfall(maxSteuerfall);
    }
    String qStbereich = &#8220;1=1&#8221;;
    Object[] argsStbereich = null;
    if (sfrom.getDurchwahl() != null) {
        qStbereich = 
            &#8220; t.steuerfall in (select s from Steuerfall s, Steuerfallbereich b &#8221; +
            &#8220; where b.telefon.nummer = ? and b.stnrVon &lt; s.stnr and b.stnrBis &gt; s.stnr)&#8221;;
        argsStbereich = new Object[]{sfrom.getDurchwahl().getNummer()};
    }
    String qPflName = &#8220;1=1&#8221;;
    Object[] argsPflName = null;
    if (sfrom.getName() != null) {
        qPflName = 
            &#8220; t.steuerfall in (select s from Steuerfall s, Pflichtiger_ZO pzo &#8221; +
            &#8220; where pzo.pflichtiger1.name1 like ? or pzo.pflichtiger2.name1 like ? &#8221; +
            &#8220; and pzo member of s.steuerfallPflichtige)&#8221;;
        argsPflName = new Object[]{sfrom.getName(), sfrom.getName()};
    }
    result = ServiceFactory.getGenService().find(between(wvFrom, wvTo),
        expression(Wiedervorlage.class, qStbereich, false, argsPflName),
        expression(Wiedervorlage.class, qPflName, false, argsStbereich));
</pre><h4 id="TheCachingBatchloadermechanism">The Caching Batchloader mechanism</h4><p>Batch loader that is optionally able to cache loaded data. Useable to optimize performance on loading several data using a single communication line.</p><p>May be used as application or session cache with simple access:</p><ul><li>ServiceFactory.instance().getCache().get(MYPARTID);</li></ul><p>The execution-method of that cache uses the implementation of <em>IBatchService</em> - implemented by the <em>GenericServiceBean</em>.</p><p><strong>Example</strong>:<br/>        final IGenericService genService = getService(IGenericService.class);<br/>        CachingBatchloader cache = ServiceFactory.instance().getCache();<br/>        cache.add(&#8220;kistsatz.all&#8221;, true, Finder.all(Kistsatz.class));<br/>        cache.add(&#8220;bundesland.all&#8221;, true, Finder.all(Bundesland.class));<br/>        Bundesland bayern = new Bundesland();<br/>        bayern.setBezeichnung(&#8220;Bayern&#8221;);<br/>        cache.add(&#8220;bayern&#8221;, true, Finder.example(bayern));<br/>        Collection<Bundesland> bundeslaender = cache.get(Bundesland.class, &#8220;bundesland.all&#8221;);<br/>        Collection<Kistsatz> kistSaetze = cache.get(Kistsatz.class, &#8220;kistsatz.all&#8221;);<br/>        bayern = cache.getSingle(Bundesland.class, &#8220;bayern&#8221;);<br/>        log(&#8220;gefundene bundeslaender: &#8221; + bundeslaender.size() + &#8220;\ngefundene kistSaetze: &#8221; + kistSaetze.size());<br/>        log(&#8220;bayern is:&#8221; + bayern);</p><h4 id="HowtoincludetheGenericServiceintoyourproject">Howto include the GenericService into your project</h4><p>to use the GenericService, you should add a session to your ejb-jar.xml file:<br/><pre><br/>	...<br/>	<display-name>my project services</display-name><br/>	<enterprise-beans><br/>		<session><br/>			<ejb-name>GenericServiceBean</ejb-name><br/>			<mapped-name>kion/IGenericService</mapped-name><br/>			<ejb-class>de.tsl2.nano.service.util.GenericServiceBean</ejb-class><br/>			<session-type>Stateless</session-type><br/>			<ejb-local-ref><br/>				<ejb-ref-name>kion/IGenericLocalService</ejb-ref-name><br/>				<local>de.tsl2.nano.service.util.IGenericLocalService</local><br/>			</ejb-local-ref><br/>			<persistence-unit-ref><br/>				<persistence-unit-ref-name>../myproject-services.jar#myprojectPersistenceUnit</persistence-unit-ref-name><br/>			</persistence-unit-ref><br/>			&lt;!--<br/>				Der folgende Eintrag &#8216;biegt&#8217; eine existente persistenceunit auf eine<br/>				andere um!<br/>			--&gt;<br/>			&lt;!--<br/>				<persistence-context-ref><br/>				<persistence-context-ref-name>persistence/kionPersistenceUnit</persistence-context-ref-name><br/>				<persistence-unit-name>../kion-services.jar#kionPersistenceUnit</persistence-unit-name><br/>				</persistence-context-ref><br/>			--&gt;<br/>		</session><br/>		...<br/>	</enterprise-beans><br/></pre></p><p>The service-access*.jar file should be included in the lib dir of your ear file.</p><h2 id="JobScheduleService">JobScheduleService</h2><h4 id="HowtoincludetheGenericServiceinyourproject">Howto include the GenericService in your project</h4><p><pre><br/>	<session><br/>		<ejb-name>JobScheduleServiceBean</ejb-name><br/>		<mapped-name>kion/IJobScheduleService</mapped-name><br/>		<ejb-class>de.tsl2.nano.service.schedule.JobScheduleServiceBean</ejb-class><br/>		<session-type>Singleton</session-type><br/>		<ejb-local-ref><br/>			<ejb-ref-name>kion/IJobScheduleLocalService</ejb-ref-name><br/>			<local>de.tsl2.nano.service.schedule.IJobScheduleLocalService</local><br/>		</ejb-local-ref><br/>		<persistence-unit-ref><br/>			<persistence-unit-ref-name>../kion-services.jar#kionPersistenceUnit</persistence-unit-ref-name><br/>		</persistence-unit-ref><br/>	</session><br/></pre></p><h3 id="SecurityAuthorizationonPermissions">Security / Authorization on Permissions</h3><p>In your <em>LoginModule</em>, the jaas user authentication and authorization is defined. all service calls will have an argument of type <em>Subject</em> holding <em>Permission</em> objects of different types. Before we discuss the different types, one important thing to know:</p><ul><li>don&#8217;t mix static permisssions (defined in your policy file) with dynamic ones (created by your <em>LoginModule</em>)! This may cause an <em>ClassCircularityError</em>.</li></ul><p>The different types of dynamic tsl2.nano.serviceaccess permissions are:</p><ul><li>user-permission: holding the name of the user</li><li>feature permissions: holding all application features to be checked</li><li>role permissions: used to authorize client actions or server side services.</li></ul><p>We do a client side login. To enable server side permission checks, the <em>ServiceLocator</em> provides a UserPrincipal to the subject, given as _Context.SECURITY_PRINCIPAL_. The server must know, how to handle the principal. In jboss we look at the login-config.xml file to select the right security domain. The <em>ClientLoginModule</em> is usable by client side logins.</p><p>login-config.xml:<br/><pre><br/>  <application-policy name="client-login"><br/>    <authentication><br/>      &lt;login-module code="org.jboss.security.ClientLoginModule"<br/>        flag=&#8220;required&#8221;&gt;<br/>         &lt;!&#8212; Any existing security context will be restored on logout --&gt;<br/>         <module-option name="restore-login-identity">true</module-option><br/>      </login-module><br/>    </authentication><br/>  </application-policy><br/></pre></p><p>The tsl2.nano.serviceaccess type <em>UserPrincipal</em> must be public to the jboss, so we have to put the jar to the jboss lib dir.</p><p>To check permissions on server side use the session-context to evaluate them.</p><p><pre><br/>@SecurityDomain(&#8220;mydomain&#8221;)<br/>@Stateless<br/>@Remote<br/>public class MyStatelessSession {<br/>	@EJB SessionContext sessionContext<br/>	...<br/>	sessionContext.getCallerPrincipal()<br/>	...<br/>}<br/></pre></p><p>If you don&#8217;t want to use SecurityDomain directly, create the file <em>jboss.xml</em> in your <em>META-INF</em> directory:</p><p><jboss><br/>   <security-domain>client-login</security-domain><br/></jboss></p><h3 id="CreatingownEntitiesandServices">Creating own Entities and Services</h3><ul><li>business logic should be implemented only in services</li><li>in a lot of cases, beans and database structure are defined by another group</li><li>the gui should work on beans without a lot work</li></ul><p>If you have to present data, provided by a lot of beans, it would be recommended to create a database view and its entity bean to minimize coding and maximize performance. but in a lot of cases, you don&#8217;t have access to the database structure &#8211; and entity beans are only created as direct images of database tables.<br/>A possible way is to create an own entity bean, not bound to a table, but to a query result. what you have to do is:</p><ul><li>create a serializable class with entity annotation &#8211; the package should be part of the ejb-beans jar!!</li><li>create at least one named query</li><li>create a SqlResultSetMapping annotation, if your fieldnames match the query result, there is nothing more to do</li><li>create the entity fields (use the same names as the named query</li><li>create public getters and setters for all fields</li><li>create a serialversion uid</li><li>create the hashCode and equals and optional the toString methods</li><li>deploy the class</li></ul><p>If you want the swartifex framework to work on your bean like a normal entity, create the two named queries &#8216;findAll&#8217; and &#8216;findById&#8217;.</p><p>Example:</p><p><pre><br/>@Entity<br/>@NamedNativeQueries({<br/>@NamedNativeQuery(name=&#8220;findAll&#8221;, resultClass=BuchungItem.class, <br/>    query = " select t1.steuerfallID, t1.buchungsdatum,t1.betrag,t1.belegNummer"<br/>    + " from "<br/>    + "   Buchung t1"<br/>    + "   left outer join Buchungszeichen t4 on t1.buchungszeichenID = t4.buchungszeichenID,"<br/>    + "   Buchungsschluessel t2"<br/>    + " where t1.buchungsschluesselID = t2.buchungsschluesselID"<br/>    + "   and t1.buchungsstatus in (&#8216;VERBUCHT&#8217;, &#8216;OFFEN&#8217;)"<br/>    + &#8220; order by t1.buchungsdatum,t1.belegnummer&#8221;),<br/>@NamedNativeQuery(name=&#8220;findBySteuerfallID&#8221;, resultClass=BuchungItem.class, <br/>    query = " select t1.steuerfallID, t1.buchungsdatum,t1.betrag,t1.belegNummer"<br/>    + " from "<br/>    + "   Buchung t1"<br/>    + "   left outer join Buchungszeichen t4 on t1.buchungszeichenID = t4.buchungszeichenID,"<br/>    + "   Buchungsschluessel t2"<br/>    + " where t1.steuerfallID = ?"<br/>    + " and t1.buchungsschluesselID = t2.buchungsschluesselID"<br/>    + "   and t1.buchungsstatus in (&#8216;VERBUCHT&#8217;, &#8216;OFFEN&#8217;)"<br/>    + &#8220; order by t1.buchungsdatum,t1.belegnummer&#8221;)}<br/>)<br/>@SqlResultSetMapping(name = &#8220;BuchungItem&#8221;)<br/>public class BuchungItem implements Serializable {<br/>    /** serialVersionUID */<br/>    private static final long serialVersionUID = -2536464338260137496L;</p>   /** kuenstliche id (wird von jpa gefordert) */
    String buchungItemID;   String steuerfallID;
    Date buchungsdatum;
    BigDecimal betrag;
    Integer belegNummer;   @Id
    public String getBuchungItemID() {
        if (buchungItemID == null) {
            buchungItemID = steuerfallID + &#8220;.&#8221; + belegNummer;
        }
        return buchungItemID;
    }   public void setBuchungItemID(String buchungItemID) {
        this.buchungItemID = buchungItemID;
    }   public BuchungItem() {
    }   public String getSteuerfallID() {
        return steuerfallID;
    }   public void setSteuerfallID(String steuerfallID) {
        this.steuerfallID = steuerfallID;
    }   public Date getBuchungsdatum() {
        return buchungsdatum;
    }   public void setBuchungsdatum(Date buchungsdatum) {
        this.buchungsdatum = buchungsdatum;
    }   public BigDecimal getBetrag() {
        return betrag;
    }   public void setBetrag(BigDecimal betrag) {
        this.betrag = betrag;
    }   public Integer getBelegNummer() {
        return belegNummer;
    }   public void setBelegNummer(Integer belegNummer) {
        this.belegNummer = belegNummer;
    }   @Override
    public int hashCode() {
    ...
    }   @Override
    public boolean equals(Object obj) {
    ...
    }
}
</pre><p>Now, you can access the beans through the generic service method 'findByNamedQuery(beanType, queryName, args...)</p><h2 id="developinganddeploying">developing and deploying</h2><p>If you change sources of this plugin, you should start the following ant scripts: </p><ul><li><em>eclipse-tsl2.nano.serviceaccess.xml</em> with target <em>swartifex.eclipse.serviceaccess.export</em> (Please be sure to use the same jre-runtime as your eclipse-workspace &#8211; otherwise nothing will be done!).</li><li>the &#8216;deploy&#8217; target of your main project.</li><li>perhaps an additional script to distribute the new libraray to a project-specific library-plugin. in <em>kion2plus</em> it is <em>kion.swartifex.plugins</em>. In <em>kion2plus</em> you run <em>kion/distribute-swartifex-plugins.xml</em> with target <em>copy.swartifex.plugins</em>.</li></ul></body></html>