# Introduction to the structure of ModelKit

The *ModelKit* should provide a flexible and configurable way to arrange new sort mechanisms. 
This can be done through given JSon text format files. Different Groups use chains of comparators 
and selectors defined by base definitions and functions and base facts/rules/agreements.

Any configuration element can be referenced through its *name* - and all configuration items inside a configuration
can reference all elements of its owning configuration.

Different ModelKits can be provided to be actived on different times or circumstances.

further informations in javadoc:
    * ModelKit (class and ModelKitLoader.class)
    * Group (class, constructor, sort(), groupByLimit(), insertion())

## Overview

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
![Diagram for Declarative Structure](https://g.gravizo.com/svg?
  digraph G {
    ModelKits -> ModelKit [label="List of ModelKits on different times/circumstances"];
    Item -> [label="items of given type to do the algorithms on"];
    ModelKit -> {Definition; Fact; NamedComparator; Group}
    Group -> {Fact; NamedComparator}
    Fact -> Definition [label="uses"];
    Func -> [label="compiled code to be done on given items (e.g. to reference an items property"];
    Definition [label="Base Definitions, like items of special groups"];
    }
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each configuration element has properties but doesn't hold any runtime informations like lists of items to be sorted.

Each *group*, as main accessible object has a sort() function and an insertion() function. these functions
get all available items of a list, filtering them through a selector and do a sort through a chain of selectable
comparators - or do insertions defined its properties 'step' and 'limit'.

*Comparators* are selective and can have sub-comparators (chain). If it isn't selectable for the given two comparing items, 
the owning group delegates to its next comparator. If a Comparator returns 0, the next selectable child comparator will be asked, if available.

*Facts* are simple functions, returning true or false. Usable as selectors for groups and comparators.
*Funcs* provide simple peace of code to get any result.
*Definitions* are the base agreements without any dependencies to other configuration elements.

To see the structure before working on it, you can print a human readable information through ModelKit.describe().

On testing, a small analzing table will be printed to see duration, item count and count of calls of each configuration element.
This may be helpfull to see, whether some elements are not selectable and result in count of calls = 0.
But the clone negative facts should not be points of interest.

Setting logging to debug enabled, you see all available elements by its names. These are reusable in json configurations:

## Dynamic Configuration through JSon

The ModelKitLoader provides all mechanisms to load from, save to, and reset (singelton configuration) json files
as configurations. To enable the mechanisms,
remove the out-comment on the rest-service and declare the @Produces in *ModelKit#getActiveModelKitNow()* as @Default.

Each configuration element is able to find each other configuration element through its parent configuration. All configuration
elements are referencable throuth its unique name.

## Fact

As facts are simple functions returning a boolean value, they can be combined through and-clause with other existing facts.
The ModelKit will clone each given fact to provide the negation, 
that can be accessed throuth its convenience function *not()*. The facts main function implementation may be null to only
combine existing facts with and-clause.  

They are used to filter groups and are used to define comparators and their selection.

## Func

Func are named lambda functions without any additional properties and are usable on the item objects (to be sorted) to evaluate item properties.

## Definition

simple values or lists, that defined some additional properties.

## NamedComparator

the main elements of group sorting. can have child comparators to be called on equality, and are selectable through a given fact.

## Group

the main elements , providing actions to be done on a list of items. they filter items through a filter, given by a fact, and use comparators 

## Technical Instructions / Informations

if new lambda expression or other coded functions are used, a new sort configuration factory class should be provided and registered,
to reload the configured elements.

IMPORTANT: 
all names will be automatically tagged with a namespace (name of parent configuration). If you use names inside of lambda expressions, you
have to tag them by yourself!

Each new implemented model kit should register itself in a class static block:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static {
    create();
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

where the static create() method creates and declares a new hard specified model kit.

The ModelKit class with its ModelKitLoader provides mechaisms to provide the hardcoded registered
model kits (to inherit the lambda implementions from) and the dynamic loaded (json) model kits (being selected as model kit).

If no json file 'modelkit.json' was found, the hard coded and registered model kits will be saved into that file.

The right sort configuration is selected through a cron expression and the function *isActive().

<style class="fallback">body{white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="http://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
